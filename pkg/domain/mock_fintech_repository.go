// Code generated by mockery v2.14.1. DO NOT EDIT.

package domain

import (
	gin "github.com/gin-gonic/gin"
	mock "github.com/stretchr/testify/mock"
)

// MockFintechRepository is an autogenerated mock type for the FintechRepository type
type MockFintechRepository struct {
	mock.Mock
}

// AddMoneyRepository provides a mock function with given fields: c, to, amount
func (_m *MockFintechRepository) AddMoneyRepository(c *gin.Context, to string, amount int) (Account, error) {
	ret := _m.Called(c, to, amount)

	var r0 Account
	if rf, ok := ret.Get(0).(func(*gin.Context, string, int) Account); ok {
		r0 = rf(c, to, amount)
	} else {
		r0 = ret.Get(0).(Account)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gin.Context, string, int) error); ok {
		r1 = rf(c, to, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddToTransaction provides a mock function with given fields: c, from, to, amount
func (_m *MockFintechRepository) AddToTransaction(c *gin.Context, from string, to string, amount int) error {
	ret := _m.Called(c, from, to, amount)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gin.Context, string, string, int) error); ok {
		r0 = rf(c, from, to, amount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAccountRepository provides a mock function with given fields: c, userName
func (_m *MockFintechRepository) GetAccountRepository(c *gin.Context, userName string) (Account, error) {
	ret := _m.Called(c, userName)

	var r0 Account
	if rf, ok := ret.Get(0).(func(*gin.Context, string) Account); ok {
		r0 = rf(c, userName)
	} else {
		r0 = ret.Get(0).(Account)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gin.Context, string) error); ok {
		r1 = rf(c, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserRepository provides a mock function with given fields: c, userName
func (_m *MockFintechRepository) GetUserRepository(c *gin.Context, userName string) (UserType, error) {
	ret := _m.Called(c, userName)

	var r0 UserType
	if rf, ok := ret.Get(0).(func(*gin.Context, string) UserType); ok {
		r0 = rf(c, userName)
	} else {
		r0 = ret.Get(0).(UserType)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gin.Context, string) error); ok {
		r1 = rf(c, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoginRepository provides a mock function with given fields: c, userName, password
func (_m *MockFintechRepository) LoginRepository(c *gin.Context, userName string, password string) error {
	ret := _m.Called(c, userName, password)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gin.Context, string, string) error); ok {
		r0 = rf(c, userName, password)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RegisterUserRepository provides a mock function with given fields: c, userName, email, password
func (_m *MockFintechRepository) RegisterUserRepository(c *gin.Context, userName string, email string, password string) (string, error) {
	ret := _m.Called(c, userName, email, password)

	var r0 string
	if rf, ok := ret.Get(0).(func(*gin.Context, string, string, string) string); ok {
		r0 = rf(c, userName, email, password)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gin.Context, string, string, string) error); ok {
		r1 = rf(c, userName, email, password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveMoneyRepository provides a mock function with given fields: c, from, amount
func (_m *MockFintechRepository) RemoveMoneyRepository(c *gin.Context, from string, amount int) (Account, error) {
	ret := _m.Called(c, from, amount)

	var r0 Account
	if rf, ok := ret.Get(0).(func(*gin.Context, string, int) Account); ok {
		r0 = rf(c, from, amount)
	} else {
		r0 = ret.Get(0).(Account)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gin.Context, string, int) error); ok {
		r1 = rf(c, from, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferMoneyRepository provides a mock function with given fields: c, from, to, amount
func (_m *MockFintechRepository) TransferMoneyRepository(c *gin.Context, from string, to string, amount int) (Account, error) {
	ret := _m.Called(c, from, to, amount)

	var r0 Account
	if rf, ok := ret.Get(0).(func(*gin.Context, string, string, int) Account); ok {
		r0 = rf(c, from, to, amount)
	} else {
		r0 = ret.Get(0).(Account)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*gin.Context, string, string, int) error); ok {
		r1 = rf(c, from, to, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewMockFintechRepository interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockFintechRepository creates a new instance of MockFintechRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockFintechRepository(t mockConstructorTestingTNewMockFintechRepository) *MockFintechRepository {
	mock := &MockFintechRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
